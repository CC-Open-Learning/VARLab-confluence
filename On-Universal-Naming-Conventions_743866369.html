<!DOCTYPE html>
<html>
    <head>
        <title>VARLab : On Universal Naming Conventions</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">VARLab</a></span>
                            </li>
                                                    <li>
                                <span><a href="947650564.html">Art/Asset Department</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            VARLab : On Universal Naming Conventions
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                            
        
    
        
    
        
        
            Created by <span class='author'> Topher Rouleau</span>, last modified on Jul 02, 2024
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <p><em>Some effort should be made to standardize the naming of parts of models in order to make working with these models easier for both the artists and the programmers. This document will likely be broken into smaller, more targeted documents under the same umbrella as we work on finalizing naming conventions.</em></p><p><em>The document is a work in progress as we try to build a set of naming conventions that are useful and easily learned (if not perfectly intuited).</em></p><p><em>Please feel free to share anything that you think would be helpful in standardizing the names, and also point out any shortcoming to the proposal below:</em></p><h2 id="OnUniversalNamingConventions-UniversalNamingConventionsforDeliveredArtAssets">Universal Naming Conventions for Delivered Art Assets</h2><p>Art assets refer to anything coming out of the art pipeline. This could include models, textures, animations, etc. When it comes to naming delivered art assets, there are a few standard practices that can be employed.</p><h3 id="OnUniversalNamingConventions-OnFileStructuring">On File Structuring</h3><p>In general, we should aim to have a deep folder structure. This can help us eliminate long file names. </p><p>As an example: Instead of naming an asset “jungleLevel_aztecTemple_stoneBrick_chiseled,” we can name it “stoneBrick_chiseled” and place that in the “Aztec_Temple” folder, and then place that folder inside the “Jungle_Level” folder. Based on the scope of our projects in the past, it seems unlikely that we need to to have as many layers of folders as the example above.</p><p>This practice helps to increase the readability of the files, and helps to keep related assets in similar places, reducing the need to query the file structure to find what we need.</p><p>These directories should be named concisely, using one or two words.</p><p>Each end-level folder should contain only one type of file extension. A folder that contains .fbx models should not also contain materials and .png textures. However, a folder of .png textures may contain .pngs that contain different information, such as albedos, normals, ambient occlusions, etc.</p><h3 id="OnUniversalNamingConventions-OnCasingofNames">On Casing of Names</h3><p>Below we’ll be talking a bit more about the files names, and names of parts of a model as a whole, but first I would like to address the casing of the names you create. Above all, we should prioritize legibility. This will likely mean leveraging either camel case or Pascal case when typing your file names. Both of these styles use capital letters to signal where words begin and end when spaces are not or cannot be used. below you can see some examples of types of casing and the benefits and issues of each:</p><p /><p><u>All Lower Case:</u></p><blockquote><p>hishowmewhatcaseslooklike</p></blockquote><p><u>All Upper Case:</u></p><blockquote><p>HISHOWMEWHATCASESLOOKLIKE</p></blockquote><p><em>Benefits of All Upper/All Lower: </em>Largely the only benefit here is the speed at which these file names can be entered, though this is a marginal benefit. Some databases may want to store file names in all upper or all lower for one reason or another, though this can usually be corrected by script</p><p><em>Drawbacks of All Upper/All Lower:</em> The largest draw back is that we lose the ability to break apart the words taht make up the file name. I’ve purposefully chosen a string of words that can be interpreted ambiguously. While there are context clues for what the words likely are, these clues may not be intuitive for a non-native speaker.</p><p>The string of letters above may be read as “ hi show me what cases look like”, which is correct, but it could also be read as “his how mew hat cases look like”, which is nonsense.</p><p /><p><u>Snake Case:</u></p><blockquote><p>hi_show_me_what_cases_look_like</p></blockquote><p><u>Kabob Case:</u></p><blockquote><p>hi-show-me-what-cases-look-like</p></blockquote><p><em>Benefits of Snake and Kabob: </em> This file name is perfectly legible, does not contain white space, and can be easily tokenized by software, in the event you need to break out all the individual words</p><p><em>Drawbacks of Snake and Kabob:</em> While this system does not have any drawbacks on it’s own, the naming convention propsed in this document seeks to use these tokenizing symbols (underscores or hyphens) to group information into a hierarchy inside the file name - more on that below.</p><p><u>Camel Case:</u></p><blockquote><p>hiShowMeWhatCasesLookLike</p></blockquote><p><u>Pascal Case:</u></p><blockquote><p>HiShowMeWhatCasesLookLike</p></blockquote><p><em>Benefits Camel and Pascal:<strong> </strong></em>The words in the file name are easily parsed by a human, though perhaps not as easily as snake case or kabob case. It does remove ambiguity from the interpretation though.</p><p><em>Drawbacks of Camel and Pascal: </em>These file names are slightly harder to tokenize, though its not impossible. Its worth noting that coding standards have expectations on when to use pascal and when to use camel to signal different parts of code, though that shouldn't cause any issues. </p><p /><p>All and all, Pascal and Camel cases remove ambiguity and allow us to use the tokenizing characters to break the file into different sections of information. The drawbacks are generally minimal and in all likelihood will not cause issues for us. </p><p><strong>The artists held a vote and the consensus is to use Pascal Case for all naming moving forward.</strong></p><h3 id="OnUniversalNamingConventions-OnNamingModelsandPrefabs">On Naming Models and Prefabs</h3><p>File names should be structured in a way that will group similar objects together. We can leverage the default alphabetical sorting to accomplish this. In general, this means adhering to a consistent naming structure and tokenizing your filenames. We could use the format of:</p><blockquote><p>[AssetType]_[Subtype]_[suffix}</p></blockquote><p>Note that not all assets will require subtypes or suffixes - we may only have one type of traffic cone. But some examples of this convention being used are as follows:</p><blockquote><p>Tree_Jungle</p><p>Tree_Jungle_Dead</p><p>Vehicle_Truck_Damaged</p><p>Vehicle_Truck_Undamaged</p></blockquote><p>Note that the use of a descriptive suffix is much more useful than serializing assets. A designer will not know if “Vehicle_Truck_01” is damaged, undamaged, or maybe just blue. </p><p>There may also be times where you need multiple suffixes, just like you might not need a suffix at all. If this is the case, please be consistent in the order of your suffixes. “Vehicle_Truck_Blue_Damaged” and “Vehicle_Truck_Damaged_Red” should not exist in the same project because one of these lists the colour and then the status, while the other lists the status and then the colour.</p><p>There may be times where a descriptive suffix is not feasible. If this is the case, we can still use a serialization. Please remember to include padding on your serialization. This means including leading zeros. This helps keeping the files organized and alphabetized. Without leading zeros for padding, an alphabetized list will be out of order. It also helps to make it more clear if a file is missing or duplicated.</p><h3 id="OnUniversalNamingConventions-OnNamingorRenamingofHistoricalAssets"><span class="inline-comment-marker" data-ref="9a270738-0860-41af-9b45-3c069276ac36">On Naming or Renaming of Historical Assets</span></h3><p>This part of the document still needs to be prepared, but Jonathan Bezeau mentioned that we should establish a standard for when and if historical assets being added to our database should be renamed. An example given was what if a historical asset has a similar or identical name and is added to the database. Do we then rely on regular serialization? Can we perhaps use a date-stamp to serialize?</p><h2 id="OnUniversalNamingConventions-UniversalNamingConventionsforModelParts">Universal Naming Conventions for Model Parts</h2><p>Parts of models should be quickly and easily identifiable by both artist and programmers. This should increase legibility of the models and hopefully increase the ease and speed at which we can all work with our models.</p><p>In order to do this, we should establish a set of naming conventions that is universal across all models (and therefore all projects) moving forward. This naming system should be consistent and descriptive, without being overly verbose. </p><p>An example of a helpful naming convention could be:</p><blockquote><p>[Type]_[MasterModel]_[Location]_[PartName]_[Serialization]</p><p>poly_Bulldozer_Left_TreadPlate_020</p></blockquote><p /><p>Note that the delimiter used is an underscores [  _<strong> </strong> ]. <em>Each individual token should follow Pascal case</em>.  The exception to this is the first token, which should always be in all lower case.</p><p>Let’s break down the information in the above example now:</p><h3 id="OnUniversalNamingConventions-FirstToken">First Token</h3><blockquote><p><strong>poly</strong>_Bulldozer_Left_TreadPlate_020</p></blockquote><p>The first token of this name signals the <u>type</u> of part that the name describes. In the case of the example “poly” stands for “poly surface”, signifying that this is a piece of mesh which will be rendered out. It is likely that most parts of a model will be poly surfaces, though this distinction is still helpful as <span class="inline-comment-marker" data-ref="32269105-757c-462b-9f06-fc5f036830e1">we will occasionally see other types, such as locators </span><em><span class="inline-comment-marker" data-ref="32269105-757c-462b-9f06-fc5f036830e1">(empties)</span></em><span class="inline-comment-marker" data-ref="32269105-757c-462b-9f06-fc5f036830e1"> and armatures </span><em><span class="inline-comment-marker" data-ref="32269105-757c-462b-9f06-fc5f036830e1">(bones)</span></em><span class="inline-comment-marker" data-ref="32269105-757c-462b-9f06-fc5f036830e1">. </span></p><div class="table-wrap"><table data-table-width="760" data-layout="default" data-local-id="d15d80d9-01c8-4f29-acae-f453a9af72fa" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p><strong>Shorthand</strong></p></th><th class="confluenceTh"><p><strong>Long Name</strong></p></th></tr><tr><td class="confluenceTd"><p>poly_</p></td><td class="confluenceTd"><p>A poly surface / mesh  geometry</p></td></tr><tr><td class="confluenceTd"><p>rig_</p></td><td class="confluenceTd"><p>denotes that this is the top level of a rig. Likely this will be full of bones</p></td></tr><tr><td class="confluenceTd"><p>bone_</p></td><td class="confluenceTd"><p>A bone, part of a rig that can manipulate a skinned mesh</p></td></tr><tr><td class="confluenceTd"><p>grp_</p></td><td class="confluenceTd"><p>A group: an empty that serves to group child elements. </p></td></tr><tr><td class="confluenceTd"><p>loc_</p></td><td class="confluenceTd"><p>A locator: an empty that will be addressed by script to snap another object to a predetermined location</p></td></tr><tr><td class="confluenceTd"><p /></td><td class="confluenceTd"><p /></td></tr></tbody></table></div><h3 id="OnUniversalNamingConventions-SecondToken">Second Token</h3><blockquote><p>poly_<strong>Bulldozer</strong>_Left_TreadPlate_020</p></blockquote><p>The second token should signify what <u>completed model</u> this is a part of. In the example, this part belongs to the bulldozer.</p><h3 id="OnUniversalNamingConventions-ThirdToken">Third Token</h3><blockquote><p>poly_Bulldozer_<strong>Left</strong>_TreadPlate_020</p></blockquote><p>On complex models, the third token should give an <u>approximate location</u> of where on the model this part is located. On less complex models, this token may be omitted.</p><p>We can be rid ambiguity by using standard terms related to the model at hand. While I have used the excavator in the screenshot below <em>(Figure 01)</em>, we could also leverage the terminology of the vehicle itself, such as “passenger side” versus ”driver side”. Boats are another good example here, as they have the established language “port”, “starboard”, “bow”, and “stern”.</p><p>We may also make further distinctions between the interior and exterior, or label it as part of another quickly recognized part or grouping , like “dashboard”.</p><p>Some models may not have terminology we can leverage, and we might have to use very general labels like “left” and “right”. While left and right can be subjective, we should also standardize this to avoid any confusion or ambiguity. Models with a clear forward facing orientation should be oriented so that they are Y-forward when imported into Unity, or whatever the program of delivery may be. </p><p>Using the world orientation of the program that the model is delivered to for the project, rather than the world orientation that the object is being created in will help us stay consistent across different workflows and programs. We can then use this Y-forward orientation as a starting point, even for models with no clear forward face:</p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" loading="lazy" src="attachments/743866369/743800840.png" data-image-src="attachments/743866369/743800840.png" data-height="408" data-width="241" data-unresolved-comment-count="0" data-linked-resource-id="743800840" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="image-20230626-142611.png" data-base-url="https://varlab-dev.atlassian.net/wiki" data-linked-resource-content-type="image/png" data-linked-resource-container-id="743866369" data-linked-resource-container-version="24" data-media-id="38f3b066-5889-4a36-a63c-cd9805618225" data-media-type="file"></span><h3 id="OnUniversalNamingConventions-FourthToken">Fourth Token</h3><blockquote><p>poly_Bulldozer_Left_<strong>TreadPlate</strong>_020</p></blockquote><p>The fourth token should give <u>a descriptive name of the part itself</u>. While we may not all be subject experts or know exactly what a part is called, try to make a concerted effort to discover the name of a part. You can ask around to see if someone else knows, or as out content experts if they’re available in a timely manner. If you can’t find out exactly what something is called, describe it in one or two words.</p><h3 id="OnUniversalNamingConventions-FifthToken">Fifth Token</h3><blockquote><p>poly_Bulldozer_Left_TreadPlate_<strong>020</strong></p></blockquote><p>The fifth token is a <u>serialization</u>. Not all parts will have this, but models that have multiple similar parts should. Note also that sometimes similar parts will exist under different tokens. In the example, this is not simply the 20th tread plate, it is the 20th tread plate poly surface on the left side of the bulldozer. This means that the right side of the bulldozer can (and should) also use the number 20 when serializing the tread plates. </p><p>This serialization will signal that multiple copies exist and should give a good indication of which part it is. We can achieve this by standardizing what order the parts are serialized. </p><p><span class="inline-comment-marker" data-ref="d5df8342-21de-4cf5-94fa-14919612c8e6">Though some models may make it more difficult to do so, we should establish a standard on which part begins the serialization and how that serialization progresses. As a general rule, we can try to find out which  2D plane the repeated parts appear on, then name the parts left to right, top to bottom, front to back when viewing the model on that plane </span><em><span class="inline-comment-marker" data-ref="d5df8342-21de-4cf5-94fa-14919612c8e6">(Figure 02)</span></em><span class="inline-comment-marker" data-ref="d5df8342-21de-4cf5-94fa-14919612c8e6">. </span></p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" loading="lazy" src="attachments/743866369/770506778.png" data-image-src="attachments/743866369/770506778.png" data-height="638" data-width="1025" data-unresolved-comment-count="0" data-linked-resource-id="770506778" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="image-20230726-153133.png" data-base-url="https://varlab-dev.atlassian.net/wiki" data-linked-resource-content-type="image/png" data-linked-resource-container-id="743866369" data-linked-resource-container-version="24" data-media-id="63b61429-ec71-49bf-81e0-8792bc3527d4" data-media-type="file"></span><p><span class="inline-comment-marker" data-ref="d5df8342-21de-4cf5-94fa-14919612c8e6">For parts that are repeated and placed radially, we can name in them in a clockwise order, with the part that appears closest to <span class="inline-comment-marker" data-ref="5a6c48a1-2ada-45ad-98de-7fe41a44312b">12 o'clock being the first in the serial</span> (</span><em><span class="inline-comment-marker" data-ref="d5df8342-21de-4cf5-94fa-14919612c8e6">Figure 03)</span></em><span class="inline-comment-marker" data-ref="d5df8342-21de-4cf5-94fa-14919612c8e6">.</span></p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" loading="lazy" src="attachments/743866369/770703385.png" data-image-src="attachments/743866369/770703385.png" data-height="708" data-width="776" data-unresolved-comment-count="0" data-linked-resource-id="770703385" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="image-20230726-155129.png" data-base-url="https://varlab-dev.atlassian.net/wiki" data-linked-resource-content-type="image/png" data-linked-resource-container-id="743866369" data-linked-resource-container-version="24" data-media-id="abc47401-fc04-4e97-87eb-0a49adc78d02" data-media-type="file"></span><p>Previously, the intention would be to separate this token with a period. Maya, however, does not allow for a period to be used in a name of an object, so we will have to also use an underscore.</p><p><span class="inline-comment-marker" data-ref="fcbcb304-d050-4554-90af-913fb0028437">Also note that it is common practice to begin a serialization with the zeroth place. That means that the first instance would get the serialization of “_000” and the second would be “_001”</span></p><p>Please remember to include padding on your serialization. This means including leading zeros. This helps in the event that we need to alphabetize the parts for some reason. Without leading zeros for padding, an alphabetized list will be out of order. It also helps to make it more clear if a name is missing or duplicated.</p><h3 id="OnUniversalNamingConventions-SpecialCase:LODTokens">Special Case: LOD Tokens</h3><blockquote><p>poly_Bulldozer_Left_TreadPlate_020_<strong>LOD0</strong><br/>poly_Bulldozer_Left_TreadPlate_020_<strong>LOD1</strong></p></blockquote><p><u><span class="inline-comment-marker" data-ref="0e0be176-402a-4fdc-9e2e-2487139c9ec9">Some objects may have a </span></u><a href="https://varlab-dev.atlassian.net/wiki/spaces/VAR/pages/838893572/On+Working+With+Generating+and+Configuring+LODs" rel="nofollow"><u><span class="inline-comment-marker" data-ref="0e0be176-402a-4fdc-9e2e-2487139c9ec9">Level of Detail</span></u></a><u><span class="inline-comment-marker" data-ref="0e0be176-402a-4fdc-9e2e-2487139c9ec9"> (LOD) system in place to help optimize graphical performance.</span></u><span class="inline-comment-marker" data-ref="0e0be176-402a-4fdc-9e2e-2487139c9ec9"> In essence, this is a system that can swap out a model based on how far away the main camera is from an object. </span></p><p>Objects that have LODs will have a final token that will always be formatted as “LOD[x]”, where x can be any number between 0 and 9, though it is incredibly unlikely that any of our projects will require more than 2 layers of details, and almost certainly will never require more than 3 layers of detail. </p><p>Each LOD is given a number, with 0 being the first. The lower the number, the higher fidelity the mesh (and sometimes the textures) will be. As the main camera moves away from an object Unity’s LOD system will attempt to swap out any mesh being drawn with a lower fidelity model that has also been prepared. </p><p>In general <strong>you should expect that if a part of a model has one LOD it will have at least 2 identically named parts, but with different and sequentiated LOD tokens.</strong> This can be very important when manipulating the model within the engine (Such as moving or removing a sub-mesh) since <strong>you will have to  make the changes to ALL of the LODs of that part</strong>, otherwise we will end up with bizarre pop-in and pop-out behaviour where objects could appear or disappear at certain distances, or even appear to move on their own.</p><p>Please follow this token formatting exactly, as configuring it properly while modelling expedites the import and setup process: when named correctly Unity is able to configure most of the LOD system at the time of import, and will even make a best guess at what distance the LODs should change based on the relative size of the object and the percentage of the screen it will take up. </p><h2 id="OnUniversalNamingConventions-NamingConventionsforTextures">Naming Conventions for Textures</h2><p>Just like models, It is important that file names are descriptive and easily understood. I propose a similar tokenizing system to that of the model parts above. Doing so empowers the search feature inside of the Unity File Explorer so that someone searching for an asset can quickly find all the related information, as well as keeping related maps grouped together in an alphabetical sort. Similarly to naming parts of models, each individual token should follow Pascal Case, with the exception of the final token that denotes the map type which will be all lower case except for the maps types that are named as initialism (MRO, CVM, etc) which should be all caps. You can find a table below.</p><p>Consider the file name:</p><blockquote><p>[ObjectName]_[SubMaterial]_[TextureVariation]_[mapTypeSuffix].[fileType]</p><p>Bulldozer_Treads_Dirty_MRO.png</p></blockquote><p>This file name is broken into several tokens:</p><h3 id="OnUniversalNamingConventions-FirstToken.1">First Token</h3><blockquote><p><strong>Bulldozer</strong>_Treads_Dirty_MRO.png</p></blockquote><p>The first token denotes <u>the model that this texture is made for</u>. In the event that the base model has a longer name, that it itself is tokenized, we should still be able to extract that most important identifier. as an example, if the model “Tree_Jungle_Damaged” can have its padding removed and shortened to “TreeJungleDamaged”. </p><p>An even better practice would be to work strategically and group our models onto similar UV sheets so that “Tree_Jungle” and “Tree_Jungle_Damaged” use the same texture maps, though there may be times when this is not possible.</p><p>This first token will be needed for all texture sheets that are generated.</p><h3 id="OnUniversalNamingConventions-SecondToken.1">Second Token</h3><blockquote><p>Bulldozer_<strong>Treads</strong>_Dirty_MRO.png</p></blockquote><p>The second token tells us <u>what targeted area or surface type</u> this texture belongs to. This is useful in the event that a model has multiple materials on it. </p><p>Not all textures will require the second token, as not all models will require multiple materials.</p><h3 id="OnUniversalNamingConventions-ThirdToken.1">Third Token</h3><blockquote><p>Bulldozer_Treads_<strong>Dirty</strong>_MRO.png</p></blockquote><p>The third token signifies <u>a texture variation</u>. Some models may require multiple states of cleanliness or wear,  such as “clean”, “dirty”, “damaged”, “worn”, etc.</p><p>Not models will need these surfacing variations and so not all textures will require this token.</p><h3 id="OnUniversalNamingConventions-FourthToken.1">Fourth Token</h3><blockquote><p>Bulldozer_Treads_Dirty_<strong>MRO</strong>.png</p></blockquote><p>The fourth token signifies the <u>type of texture map</u> being presented. In the example above, “MRO” indicates that this is a hybridized map that contains information for Metallic, Roughness, and Ambient Occlusion in the Red, Green, and Blue channels accordingly.<br/></p><p>This fourth token is needed for all exported textures. </p><p>Other texture map short-hands are listed below with any alternative or colloquial names. Note that this list is meant to account for all map types you may encounter, though we may not use all of them:</p><div class="table-wrap"><table data-table-width="760" data-layout="default" data-local-id="045f166a-89a0-492f-b080-8be79279e3c6" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p><strong>Short-hand</strong></p></th><th class="confluenceTh"><p><strong>Alternate Names</strong></p></th><th class="confluenceTh"><p><strong>Notes</strong></p></th></tr><tr><td class="confluenceTd"><p>_<span class="inline-comment-marker" data-ref="23b17055-3261-449c-a51e-5942f67ae2b9">colour</span></p></td><td class="confluenceTd"><p>colour, base colour, albedo</p></td><td class="confluenceTd"><p>contains just the base colour information of the surface. Uses the RGB channels. Can also contain an alpha map in the A channel.</p></td></tr><tr><td class="confluenceTd"><p>_rough</p></td><td class="confluenceTd"><p>rough, roughness</p></td><td class="confluenceTd"><p>contains information on light scatters on a surface. Uses greyscale.</p></td></tr><tr><td class="confluenceTd"><p>_metal</p></td><td class="confluenceTd"><p>metal, metallic</p></td><td class="confluenceTd"><p>contains information on how light reflects off a surface. Uses greyscale.</p></td></tr><tr><td class="confluenceTd"><p>_alpha</p></td><td class="confluenceTd"><p>alpha, opacity</p></td><td class="confluenceTd"><p>contains information on where light can pass through a surface. Uses greyscale.</p></td></tr><tr><td class="confluenceTd"><p>_bump</p></td><td class="confluenceTd"><p>bump</p></td><td class="confluenceTd"><p>contains information of the height of areas of the surface, but <strong>not</strong> the angle of the raised area. This is surface only and does not affect the silhouette of the model. Affects how light interacts with the surface. Uses greyscale.</p></td></tr><tr><td class="confluenceTd"><p>_normal</p></td><td class="confluenceTd"><p>normal</p></td><td class="confluenceTd"><p>contains information on the height <strong>and</strong> angles of the raised points on a surface. This is surface only and does not affect the silhouette of the model. Affects how light interacts with the surface. Uses RGB.</p></td></tr><tr><td class="confluenceTd"><p>_displacement</p></td><td class="confluenceTd"><p>displacement</p></td><td class="confluenceTd"><p>contains deformer information that raises parts of the surface. A displacement map <strong>does</strong> affect the silhouette of the model. Uses greyscale.</p></td></tr><tr><td class="confluenceTd"><p>_ao</p></td><td class="confluenceTd"><p>occlusion, ambient occlusion</p></td><td class="confluenceTd"><p>contains information on parts of the model that have shadow. Changes how light interacts with these areas in regards to their metallic and roughness properties. Uses greyscale.</p></td></tr><tr><td class="confluenceTd"><p>_diffuse</p></td><td class="confluenceTd"><p>diffuse</p></td><td class="confluenceTd"><p>contains information of the base colour with the ambient occlusion baked onto it. Note that because the occlusion is baked onto the map, it cannot affect how light interacts with the shadowed areas. Uses RGB. Can contain an alpha map in the A channel.</p></td></tr><tr><td class="confluenceTd"><p>_MRO</p></td><td class="confluenceTd"><p>Hybrid metal + roughness + ambient occlusion</p></td><td class="confluenceTd"><p>A hybridized texture with information for metallic in the R channel, roughness in the G channel, and ambient occlusion in the B channel.</p></td></tr><tr><td class="confluenceTd"><p><span class="inline-comment-marker" data-ref="7a814e1e-7681-4f2e-8029-509bfdcb6ef5">_CVM</span></p></td><td class="confluenceTd"><p>colour variation mask</p></td><td class="confluenceTd"><p>contains image for masking an area of colour to create colour variations from inside of the engine. Uses greyscale if the shader only supports on tint, but the proprietary <em><span class="inline-comment-marker" data-ref="3d9867e2-2e86-4e82-9750-88de8ac14616">MRO Universal Workflow - Triple Mask Shader</span></em> will support three masks in a single RGB image.</p></td></tr><tr><td class="confluenceTd"><p>_MS</p></td><td class="confluenceTd"><p>metallic, smoothness</p></td><td class="confluenceTd"><p>contains information for both a metallic and Smoothness, as Unity’s default shader expects. Metallic is stored in a the RGB channels combined as greyscale, and Smoothness is stored in the alpha channel.</p></td></tr><tr><td class="confluenceTd"><p>_emis</p></td><td class="confluenceTd"><p>emissive</p></td><td class="confluenceTd"><p>contains information for areas that glow/reject shadows. Stored in RGB channels.</p></td></tr><tr><td class="confluenceTd"><p /></td><td class="confluenceTd"><p /></td><td class="confluenceTd"><p /></td></tr></tbody></table></div><p /><p>Staying on top of these names should be fairly painless, assuming you have set up your substance so that it exports files appropriately. Primarily, we will be delivering an MRO, Normal, and Colour maps as seen in <span class="inline-comment-marker" data-ref="7f6fc4b8-ebdd-4686-b857-53fa6088b027">(</span><em><span class="inline-comment-marker" data-ref="7f6fc4b8-ebdd-4686-b857-53fa6088b027">Figure 04)</span></em><span class="inline-comment-marker" data-ref="7f6fc4b8-ebdd-4686-b857-53fa6088b027">.</span></p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" loading="lazy" src="attachments/743866369/813858818.png" data-image-src="attachments/743866369/813858818.png" data-height="543" data-width="768" data-unresolved-comment-count="0" data-linked-resource-id="813858818" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="Untitled-20230927-140330.png" data-base-url="https://varlab-dev.atlassian.net/wiki" data-linked-resource-content-type="image/png" data-linked-resource-container-id="743866369" data-linked-resource-container-version="24" data-media-id="b470b8f2-493c-4565-a77a-57544630c951" data-media-type="file"></span><p><span class="inline-comment-marker" data-ref="8273dbed-b3bd-4a90-80af-d10fe789dc89">When it comes to creating _CVM, or colour variation masks, these will be made-to order</span>, and not all assets will require them. Sometimes this may mean creating them manually by tracing over the colour map in Photoshop, and other times we may be able to export masking channels from substance and use them to create the CVM, also in Photoshop.</p><h2 id="OnUniversalNamingConventions-OnPackingTextures">On Packing Textures</h2><p>Different projects will have different needs in terms of textures depending on the render path of the project it is being delivered to. Ensure that the textures you deliver consist of all the required texture maps, and only the required texture maps. Your deliverables may change from project to project, so be aware of what texture maps are needed based on the project you are currently working on!</p><p>Textures should be organized into a file structure as in <a href="3D-Asset-Core-Deliverables-At-a-Glance_775618689.html" data-linked-resource-id="775618689" data-linked-resource-version="10" data-linked-resource-type="page">this document</a>, especially in the event of texture variations. </p><p />
                    </div>

                                        <div class="pageSection group">
                        <div class="pageSectionHeader">
                            <h2 id="attachments" class="pageSectionTitle">Attachments:</h2>
                        </div>

                        <div class="greybox" align="left">
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/743866369/743800840.png">image-20230626-142611.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/743866369/770703379.png">image-20230726-153026.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/743866369/770506778.png">image-20230726-153133.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/743866369/770375702.png">image-20230726-155115.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/743866369/770703385.png">image-20230726-155129.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/743866369/771391496.png">image-20230726-175943.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/743866369/813858818.png">Untitled-20230927-140330.png</a> (image/png)
                                <br/>
                                                    </div>
                    </div>
                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Jul 04, 2025 14:43</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
